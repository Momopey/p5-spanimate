{"src":"\n\n// Maximum number of iterations for each point on the complex plane\nconst maxiterations = 250;\n\n// Colors to be used for each possible iteration count\nconst colorsRed = [];\nconst colorsGreen = [];\nconst colorsBlue = [];\n\ns.setup = ()=>{\n  s.pixelDensity(1);\n  s.createCanvas(400, 400);\n  s.colorMode(s.HSB, 1);\n\n  // Create the colors to be used for each possible iteration count\n  for (let n = 0; n < maxiterations; n++) {\n    // Gosh, we could make fancy colors here if we wanted\n    let hu = s.sqrt(n / maxiterations);\n    let col = s.color(hu, 255, 150);\n    colorsRed[n] = s.red(col);\n    colorsGreen[n] = s.green(col);\n    colorsBlue[n] = s.blue(col);\n  }\n}\n\ns.draw = ()=>{\n  // let ca = map(mouseX, 0, width, -1, 1); //-0.70176;\n  // let cb = map(mouseY, 0, height, -1, 1); //-0.3842;\n  let param = e.get(\"param\")\n  let ca = param.x; //sin(angle);\n  let cb = param.y;\n\n\n  s.background(255);\n\n  // Establish a range of values on the complex plane\n  // A different range will allow us to \"zoom\" in or out on the fractal\n\n  // It all starts with the width, try higher or lower values\n  //let w = abs(sin(angle)) * 5;\n  let w = 5 * Math.pow(0.5, e.get(\"scale\"));\n  let h = (w * s.height) / s.width;\n\n  // Start at negative half the width and height\n  let pos = e.get(\"pos\")\n  let xmin = pos.x + (-w / 2);\n  let ymin = pos.y + (-h / 2);\n\n  // Make sure we can write to the pixels[] array.\n  // Only need to do this once since we don't do any other drawing.\n  s.loadPixels();\n\n  // x goes from xmin to xmax\n  let xmax = xmin + w;\n  // y goes from ymin to ymax\n  let ymax = ymin + h;\n\n  // Calculate amount we increment x,y for each pixel\n  let dx = (xmax - xmin) / s.width;\n  let dy = (ymax - ymin) / s.height;\n\n  // Start y\n  let y = ymin;\n  for (let j = 0; j < s.height; j++) {\n    // Start x\n    let x = xmin;\n    for (let i = 0; i < s.width; i++) {\n      // Now we test, as we iterate z = z^2 + cm does z tend towards infinity?\n      let a = x;\n      let b = y;\n      let n = 0;\n      while (n < maxiterations) {\n        let aa = a * a;\n        let bb = b * b;\n        // Infinity in our finite world is simple, let's just consider it 16\n        if (aa + bb > 4.0) {\n          break; // Bail\n        }\n        let twoab = 2.0 * a * b;\n        a = aa - bb + ca;\n        b = twoab + cb;\n        n++;\n      }\n\n      // We color each pixel based on how long it takes to get to infinity\n      // If we never got there, let's pick the color black\n      let pix = (i + j * s.width) * 4;\n      if (n == maxiterations) {\n        s.pixels[pix + 0] = 0;\n        s.pixels[pix + 1] = 0;\n        s.pixels[pix + 2] = 0;\n      } else {\n        // Otherwise, use the colors that we made in setup()\n        s.pixels[pix + 0] = colorsRed[n];\n        s.pixels[pix + 1] = colorsGreen[n];\n        s.pixels[pix + 2] = colorsBlue[n];\n      }\n      x += dx;\n    }\n    y += dy;\n  }\n  s.updatePixels();\n}","edit":{"param":{"valueInfo":{"type":"Vector2","value":{"x":0.37335937499999994,"y":0.31000000000000005,"z":0},"editOrigin":{"x":0,"y":0,"z":0},"editScale":1}},"scale":{"valueInfo":{"type":"number","value":7.517,"max":20,"min":0,"step":0.001}},"pos":{"valueInfo":{"type":"Vector2","value":{"x":0.17547744750976565,"y":0.47751953124999996,"z":0},"editOrigin":{"x":0.1749044799804688,"y":0.47593749999999996,"z":0},"editScale":0.001953125}}}}